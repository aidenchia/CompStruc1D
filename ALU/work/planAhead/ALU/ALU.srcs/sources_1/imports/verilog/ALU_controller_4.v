/*
   This file was generated automatically by the Mojo IDE version B1.3.6.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module alu_controller_4 (
    input clk,
    input rst,
    input [15:0] numbers,
    input next,
    output reg [15:0] out,
    output reg [4:0] test,
    output reg [7:0] io_seg,
    output reg [3:0] io_sel
  );
  
  
  
  localparam IDLE_state = 3'd0;
  localparam ALUFN_state = 3'd1;
  localparam A_state = 3'd2;
  localparam B_state = 3'd3;
  localparam ANSWER_state = 3'd4;
  
  reg [2:0] M_state_d, M_state_q = IDLE_state;
  wire [8-1:0] M_seg_seg;
  wire [4-1:0] M_seg_sel;
  reg [16-1:0] M_seg_values;
  multi_seven_seg_6 seg (
    .clk(clk),
    .rst(rst),
    .values(M_seg_values),
    .seg(M_seg_seg),
    .sel(M_seg_sel)
  );
  wire [6-1:0] M_ram1_read_data;
  reg [0-1:0] M_ram1_address;
  reg [6-1:0] M_ram1_write_data;
  reg [1-1:0] M_ram1_write_en;
  simple_ram_7 #(.SIZE(3'h6), .DEPTH(1'h1)) ram1 (
    .clk(clk),
    .address(M_ram1_address),
    .write_data(M_ram1_write_data),
    .write_en(M_ram1_write_en),
    .read_data(M_ram1_read_data)
  );
  wire [16-1:0] M_ram2_read_data;
  reg [0-1:0] M_ram2_address;
  reg [16-1:0] M_ram2_write_data;
  reg [1-1:0] M_ram2_write_en;
  simple_ram_8 #(.SIZE(5'h10), .DEPTH(1'h1)) ram2 (
    .clk(clk),
    .address(M_ram2_address),
    .write_data(M_ram2_write_data),
    .write_en(M_ram2_write_en),
    .read_data(M_ram2_read_data)
  );
  wire [16-1:0] M_ram3_read_data;
  reg [0-1:0] M_ram3_address;
  reg [16-1:0] M_ram3_write_data;
  reg [1-1:0] M_ram3_write_en;
  simple_ram_8 #(.SIZE(5'h10), .DEPTH(1'h1)) ram3 (
    .clk(clk),
    .address(M_ram3_address),
    .write_data(M_ram3_write_data),
    .write_en(M_ram3_write_en),
    .read_data(M_ram3_read_data)
  );
  
  wire [16-1:0] M_alu_out;
  reg [6-1:0] M_alu_alufn;
  reg [16-1:0] M_alu_a;
  reg [16-1:0] M_alu_b;
  alu_unit_10 alu (
    .alufn(M_alu_alufn),
    .a(M_alu_a),
    .b(M_alu_b),
    .out(M_alu_out)
  );
  
  always @* begin
    M_state_d = M_state_q;
    
    M_seg_values = 16'heeee;
    M_ram1_address = 1'h0;
    M_ram1_write_data = 6'bxxxxxx;
    M_ram1_write_en = 1'h0;
    M_ram2_address = 1'h0;
    M_ram2_write_data = 16'bxxxxxxxxxxxxxxxx;
    M_ram2_write_en = 1'h0;
    M_ram3_address = 1'h0;
    M_ram3_write_data = 16'bxxxxxxxxxxxxxxxx;
    M_ram3_write_en = 1'h0;
    M_alu_alufn = 16'bxxxxxxxxxxxxxxxx;
    M_alu_a = 16'bxxxxxxxxxxxxxxxx;
    M_alu_b = 16'bxxxxxxxxxxxxxxxx;
    test = 5'h01;
    out = 16'h0000;
    io_sel = 4'h0;
    io_seg = 8'hff;
    
    case (M_state_q)
      IDLE_state: begin
        M_seg_values = 16'h0123;
        io_seg = M_seg_seg;
        io_sel = ~M_seg_sel;
        if (next) begin
          M_state_d = ALUFN_state;
        end
      end
      ALUFN_state: begin
        M_seg_values = 16'h42f8;
        io_seg = M_seg_seg;
        io_sel = ~M_seg_sel;
        M_ram1_write_data = numbers;
        M_ram1_write_en = 1'h1;
        test = 5'h02;
        if (next) begin
          M_state_d = A_state;
        end
      end
      A_state: begin
        M_seg_values = 16'h4eee;
        io_seg = M_seg_seg;
        io_sel = ~M_seg_sel;
        M_ram2_write_data = numbers;
        M_ram2_write_en = 1'h1;
        test = 5'h04;
        if (next) begin
          M_state_d = B_state;
        end
      end
      B_state: begin
        M_seg_values = 16'h7eee;
        io_seg = M_seg_seg;
        io_sel = ~M_seg_sel;
        M_ram3_write_data = numbers;
        M_ram3_write_en = 1'h1;
        test = 5'h08;
        if (next) begin
          M_state_d = ANSWER_state;
        end
      end
      ANSWER_state: begin
        M_seg_values = 16'h485e;
        io_seg = M_seg_seg;
        io_sel = ~M_seg_sel;
        M_alu_alufn = M_ram1_read_data;
        M_alu_a = M_ram2_read_data;
        M_alu_b = M_ram3_read_data;
        test = 5'h10;
        out = M_alu_out;
        if (next) begin
          M_state_d = IDLE_state;
        end
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_state_q <= 1'h0;
    end else begin
      M_state_q <= M_state_d;
    end
  end
  
endmodule
